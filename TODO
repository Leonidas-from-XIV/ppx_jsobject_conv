
1) non existing key in jsobject -- valid option value (None):
    type r = {age: int option; name: string option; smthing: float option} [@@deriving jsobject]
    #js: {age: 13} -> {age: Some(13); name: None; smthing: None}
    #js: {age: 32, name:"john appleseed"} -> {age: Some(32); name: Some("john appleseed"); smthing: None}
    maybe optional? undefined_as_option or null_as_only_option
2) move Optdef.t handling from generated code to individual funcs?
3) is_defined: 'a Optdef.t -> ('a, string) Result.t
4) insert it when needed only
5) tests
6) alternative conversions for sum types/variants -- type op = Gte of int | Lte of int  -- {gte: x} or {lte:x}
   maybe we should convert null-ar constructors as just strings? (optionally)
     type sex = Male | Female [@@deriving jsobject]
     jsobject_of_sex Male -> 'Male'; as opposed to ['Male']
       this will complicate js -> ocaml converter
7) support for renames ^ $gte; easy [@@jsobject, lowercase] or smth, for uniform conversions
8) simple objects translations?
9) functions:
      - for callbacks, that should receive js objects, convert it to wrapped functions,
        where wrapper will convert types;

10) defaults -- implement by this lib or leave it to logic?
    not to hard to implement for basic types: add ?default arg and pass it in codegen
    not sure about complex types, where should typechecking be implemented?

Related problems, but probably out of the scope:
   Convert function({a:{}, b:{}, c:{}}), where some of the keys may be absent,
   to fun ?a ?b ?c
